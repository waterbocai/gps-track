# encoding: utf-8
'''
Created on 2011-1-5
@author: codeback@gmail.com
'''
import hashlib
import urllib2 
import urllib 
from product.model.config import db
import json
import time
import re

   
def post(url, data): 
    req = urllib2.Request(url) 
    data = urllib.urlencode(data)
    #enable cookie 
    opener = urllib2.build_opener(urllib2.HTTPCookieProcessor()) 
    response = opener.open(req, data) 
    ret = response.read()
    return urllib.unquote(ret)
    
verfyURL={
    "https":"https://www.alipay.com/cooperate/gateway.do?service=notify_verify",
    "http" :"http://notify.alipay.com/trade/notify_query.do?",
    }

#授权
service = {
    "trade":"alipay.wap.trade.create.direct",
    "auth" :"alipay.wap.auth.authAndExecute"
}

class Alipay:
    def __init__(self,partner="2088711641414841",key="60p0nfutjvrumf31g89uh2facd1vjs3w"):
        self.partner  =partner
        self.key      =key
        self.http_url ="http://wappaygw.alipay.com/service/rest.htm"
              
    def genOrderParams(self,order):
        req_data = ["<direct_trade_create_req>"]
        for k in order:
            req_data.append("<"+k+">"+order[k]+"</"+k+">")
        req_data.append("</direct_trade_create_req>")
        req_data= "".join(req_data)
        _params ={
            "req_data":req_data,
            "service" :"alipay.wap.trade.create.direct",
            "sec_id"  :"MD5",
            "partner" :self.partner,
            "req_id"  :order["seq_id"],
            "format"  :"xml", 
            "v"       :"2.0"
        }
        sign=self.buildSign(_params)
        _params["sign"]=sign
        return _params
    
    #创建支付宝订单    
    def createAlipayOrder(self,order,payid):
        params=self.genOrderParams(order)
        accessUrl = self.http_url+self.populateURLStr(params)
        
        stringjson = post(self.http_url,params)
        data = self.analyzeRet(stringjson)
        #stringjson = f.read()
        #做好调度记录
        db.update("AliPayOrder",where="id=%d"%payid,pay_params = accessUrl,
                                                 create_at=time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
                                                 ret=stringjson,
                                                 token = data["request_token"],
                                                 out_trade_no=order['out_trade_no']
                  )
        return data["request_token"]
    
    #启动支付
    def createrAuthAndExecuteUrl(self,payid):
        _ret = db.query("SELECT * FROM AliPayOrder WHERE id=%d"%payid)
        payorder=_ret[0]
        req_data="<auth_and_execute_req><request_token>%s</request_token></auth_and_execute_req>"%payorder.token
        _params = {"format"  :"xml", 
                   "v"       :"2.0",
                   "service" :"alipay.wap.auth.authAndExecute",
                   "sec_id"  :"MD5",
                   "partner" :self.partner,
                   "req_data":req_data
                   }
        sign = self.buildSign(_params)
        _params["sign"]=sign
        ret = self.http_url+"?"+self.populateURLStr(_params)
        #print "createrAuthAndExecuteUrl:%s"%ret
        return ret
                   
    def analyzeRet(self,retStr):
        items = retStr.split("&")
        p1=re.compile(r'^([^=]+)=(.+)$')
        p2 = re.compile(r'</?request_token>')
        ret ={}
        for item in items :
            m = p1.match(item)
            if m == None:
                continue
            if m.group(1) != "res_data":
                ret[m.group(1)] = m.group(2)
            else :
                temp = p2.split(m.group(2))
                ret["request_token"]=temp[1]
        return ret
    
    def populateURLStr(self,params):
        ks=params.keys()
        ks.sort()
        rlt=''
        #db.insert("test",f2=json.dumps(params))
        for k in ks:
            rlt=rlt+"&%s=%s"%(k,params[k])
        #print "URL:"+rlt[1:]
        return rlt[1:]
        

    def buildSign(self,params):
        sign=hashlib.md5(self.populateURLStr(params)+self.key).hexdigest()
        #print "md5 sign is %s" % sign;
        return sign
    
    
    '''
      校验支付宝返回的参数，交易成功的通知回调.
      校验分为两个步骤：检查签名是否正确、访问支付宝确认当前数据是由支付宝返回。
      params为支付宝传回的数据。
    '''
    def notifiyCall(self,params,verify=True,transport="http"):
        sign=None
        if params.has_key('sign'):
            sign=params['sign']
        locSign=self.buildSign(params)
        
        if sign==None or locSign!=sign:
            print "sign error."
            return "fail"
        
        if params['trade_status']!='TRADE_FINISHED' and  params['trade_status']!='TRADE_SUCCESS':
            return "fail"
        
        if not verify:
            return "success"
        else:
            print "Verify the request is call by alipay.com...."
            url = verfyURL[transport] + "&partner=%s&notify_id=%s"%(self.conf['partner'],params['notify_id'])
            response=urllib2.urlopen(url)
            html=response.read()
       
            print "aliypay.com return: %s" % html
            if html=='true':
                return "success"
            
            return "fail"

    '''
        生成提交到支付宝的表单，用户通过此表单将订单信息提交到支付宝。
        
        由params参数提供订单信息，必须包含以下几项内容：
        out_trade_no：订单号
        subject     :订单名称、或商品名称
        body        :订单备注、描述
        total_fee   :总额
    '''
    def createPayForm(self,params,method="POST",title="确认，支付宝付款"):
        params.update(self.conf)
        sign=self.buildSign(params)
        params['sign']=sign
        
        ele=""
        for nm in params:
            if params[nm]==None or len(params[nm])==0 or nm=='_input_charset':
                continue
            ele = ele + " <input type='hidden' name='%s' value='%s' />" % (nm,params[nm])
        html='''
            <form name='alipaysubmit' action='%s?_input_charset=%s' method='%s' target='_blank'>
                %s
                <input type="submit" value="%s" />
            </form>
            ''' % (gateway,params['_input_charset'],method,ele,title)
            
        return html
        
    def genPayForm(self,params):
        params.update(self.conf)
        sign=self.buildSign(params)
        params['sign']=sign
        keys = []
        for nm in params:
            if params[nm]==None or len(params[nm])==0 or nm=='_input_charset':
                keys.append(nm)
        for k in keys :
            del params[k]
        return params